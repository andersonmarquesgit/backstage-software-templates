name: ${{values.app_name}}-cicd

on:
  push:
    branches: [ main ]
    paths:
      - 'cmd/**'
      - 'Dockerfile'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/${{values.app_name}}-cicd.yml'
  workflow_dispatch:

jobs:
  ci:
    runs-on: ubuntu-latest
    permissions:
      contents: read  # necessário para metadata-action ler refs/labels
    outputs:
      image_tag: ${{ '${{ steps.imgtag.outputs.tag }}' }}

    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ '${{ secrets.DOCKERHUB_USERNAME }}' }}
          password: ${{ '${{ secrets.DOCKERHUB_TOKEN }}' }}

      # Gera tags e labels automaticamente (sha curto, nome do branch e latest no branch padrão)
      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: andersonmarquesdocker/${{values.app_name}}
          tags: |
            type=sha,format=short
            type=ref,event=branch
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Compute primary image tag
        id: imgtag
        run: echo "tag=sha-${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            andersonmarquesdocker/${{values.app_name}}:${{ '${{ steps.imgtag.outputs.tag }}' }}
            ${{ '${{ steps.meta.outputs.tags }}' }}
          labels: ${{ '${{ steps.meta.outputs.labels }}' }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
  cd:
    needs: ci
    runs-on:
       group: Default
       labels: [self-hosted, Linux, X64]
    permissions:
      contents: write          # <-- necessário para commitar/pushar
    env:
      IMAGE_REPO: andersonmarquesdocker/${{values.app_name}}
      IMAGE_TAG: ${{ '${{ needs.ci.outputs.image_tag }}' }}
      CHART_PATH: charts/${{values.app_name}}
      VALUES_FILE: charts/${{values.app_name}}/values-${{values.app_env}}.yaml

    steps:
      - name: Checkout repo (com credenciais p/ push)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0        # garante histórico completo p/ push
          persist-credentials: true

      - name: Install yq (no sudo)
        shell: bash
        run: |
          YQ_VER=v4.44.3
          YQ_URL="https://github.com/mikefarah/yq/releases/download/${{ '${YQ_VER}' }}/yq_linux_amd64"
          mkdir -p "${{ '$HOME' }}/.local/bin"
          curl -fsSL "${{ '$YQ_URL' }}" -o "${{ '$HOME' }}/.local/bin/yq"
          chmod +x "${{ '$HOME' }}/.local/bin/yq"
          echo "${{ '$HOME' }}/.local/bin" >> "${{ '$GITHUB_PATH' }}"

      - name: Update values & push (rebase-safe)
        shell: bash
        env:
          GIT_AUTHOR_NAME: github-actions[bot]
          GIT_AUTHOR_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
          BRANCH: ${{ '${{ github.ref_name }}' }}
          GITHUB_TOKEN: ${{ '${{ secrets.GITHUB_TOKEN }}' }}
        run: |
          set -euo pipefail
          
          # Garante que estamos na ponta mais recente do branch
          git fetch origin "${{ '$BRANCH' }}"
          git checkout "${{ '$BRANCH' }}"
          git pull --rebase origin "${{ '$BRANCH' }}"
          
          # Atualiza a tag da imagem
          yq -i '.image.tag = env(IMAGE_TAG)' "${{ '${VALUES_FILE}' }}"
          
          # Só commita/pusha se houve mudança
          if git diff --quiet -- "${{ '${VALUES_FILE}' }}"; then
            echo "Sem mudanças em ${{ '${VALUES_FILE}' }}; pulando push."
            exit 0
          fi
          
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${{ '${VALUES_FILE}' }}"
          git commit -m "chore(cd): bump image to ${{ '${IMAGE_REPO}' }}:${{ '${IMAGE_TAG}' }} [skip ci]"
          
          # Garante que o push use o token (útil em runners self-hosted)
          git config --global url."https://x-access-token:${{ '${GITHUB_TOKEN}' }}@github.com/".insteadOf "https://github.com/"
          
          git push origin "HEAD:${{ '${BRANCH}' }}"

      - name: Install Argo CD CLI
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL -o /tmp/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x /tmp/argocd
          # tenta /usr/local/bin, se não puder, usa ~/.local/bin
          install -m 0755 /tmp/argocd /usr/local/bin/argocd 2>/dev/null || {
            mkdir -p "$HOME/.local/bin"
            install -m 0755 /tmp/argocd "$HOME/.local/bin/argocd"
            echo "$HOME/.local/bin" >> "${{ '$GITHUB_PATH' }}"
          }
          argocd version --client
          
      - name: Criar Application no Argo CD (se não existir)
        shell: bash
        env:
          APP_NAME: ${{ '${{ github.event.repository.name }}' }}            # ex: go-app-backstage-4
          CHART_PATH: ${{ '${{ env.CHART_PATH }}' }}                        # ex: charts/go-app-backstage-4
        run: |
          set -euo pipefail

          # Tenta obter; se falhar, cria
          if ! argocd app get "$APP_NAME" >/dev/null 2>&1; then
            echo "Application $APP_NAME não existe. Criando…"
            argocd app create "$APP_NAME" \
              --repo "https://github.com/${{ '${{ github.repository }}' }}.git" \
              --path "${{ '$CHART_PATH' }}" \
              --revision main \
              --dest-server https://kubernetes.default.svc \
              --dest-namespace devops \
              --project default
          else
            echo "Application ${{ '$APP_NAME' }} já existe."
          fi

      - name: Argo CD login + sync
        shell: bash
        run: |
          # Service interno do cluster (porta 80, HTTP)
          ARGOCD_SERVER="argocd-server.argocd.svc.cluster.local:80"
          
          argocd login "${{ '$ARGOCD_SERVER' }}" \
            --username admin \
            --password '${{ '${{ secrets.ARGOCD_PASSWORD }}' }}' \
            --grpc-web \
            --plaintext
          
          # sincroniza e espera ficar saudável
          argocd app sync ${{values.app_name}} --timeout 300
          argocd app wait ${{values.app_name}} --health --timeout 300